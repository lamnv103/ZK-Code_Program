generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id            String        @id @default(uuid())
  email         String        @unique
  name          String?       // Made optional to match existing structure
  passwordHash  String
  walletAddress String        @unique
  encryptedKey  String        @db.Text // Store encrypted private key
  transferPin   String?       @db.Text // Encrypted transfer PIN
  status        String        @default("active") // active, suspended, etc.
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  // Relations
  balance       Balance?
  transactions  Transaction[] @relation("UserTransactions")
  deposits      Deposit[]     // New relation for deposits
  sentTransfers     Transfer[] @relation("SentTransfers")
  receivedTransfers Transfer[] @relation("ReceivedTransfers")
}

model Balance {
  id               String   @id @default(uuid())
  userId           String   @unique
  encryptedBalance String   @db.Text // Hidden/encrypted balance
  commitment       String   @db.Text // Hash(commit(balance, nonce))
  lastUpdated      DateTime @default(now())
  
  // Relations
  user User @relation(fields: [userId], references: [id])
}

model Transaction {
  id          String   @id @default(uuid())
  fromAddress String
  toAddress   String
  amount      Decimal  @db.Decimal(20, 8) // Keep high precision for crypto
  status      String   @default("pending") // pending, verified, failed
  zkProofHash String?  // Made optional and unique for quick lookup
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt // Added updatedAt field
  userId      String
  
  // Relations
  user    User     @relation("UserTransactions", fields: [userId], references: [id])
  zkProof ZkProof?
  
  @@index([userId, status]) // Index for better query performance
  @@index([createdAt])      // Index for sorting by date
}

model ZkProof {
  id            String   @id @default(uuid())
  transactionId String   @unique
  proofData     Json     @db.Json // Full ZKP data (json encoded)
  publicSignals Json     @db.Json // Signals needed for verification
  status        String   @default("pending") // pending, verified, failed
  zkProofHash   String?  @unique // Ä‘áº£m báº£o má»—i ZKP cÃ³ hash duy nháº¥t
  createdAt     DateTime @default(now())
  verificationTime Int?     // ðŸ‘ˆ Pháº£i Ä‘Ãºng kiá»ƒu Int hoáº·c Float
  updatedAt        DateTime @updatedAt // thÃªm dÃ²ng nÃ y náº¿u muá»‘n tá»± cáº­p nháº­t má»—i khi record thay Ä‘á»•i
  balanceCommitment String?  // âœ… thÃªm náº¿u báº¡n dÃ¹ng trong code
  nullifierHash     String?  // âœ… thÃªm náº¿u báº¡n dÃ¹ng trong code

  // Relations
  transaction Transaction @relation(fields: [transactionId], references: [id])
}


// New model for deposit functionality
model Deposit {
  id               String   @id @default(uuid())
  userId           String
  amount           Decimal  @db.Decimal(20, 8) // Match Transaction precision
  status           String   @default("pending") // pending, completed, failed
  virtualQrCodeUrl String?  @db.Text // URL to the virtual QR code image
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  
  // Relations
  user User @relation(fields: [userId], references: [id])
  
  @@index([userId, status]) // Index for better query performance
  @@index([createdAt])      // Index for sorting by date
}

// New model for transfers between users
model Transfer {
  id              String   @id @default(uuid())
  fromUserId      String
  toUserId        String
  fromWalletAddress String
  toWalletAddress   String
  amount          Decimal  @db.Decimal(20, 8)
  status          String   @default("pending") // pending, completed, failed
  description     String?  @db.Text
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  fromUser User @relation("SentTransfers", fields: [fromUserId], references: [id])
  toUser   User @relation("ReceivedTransfers", fields: [toUserId], references: [id])
  
  @@index([fromUserId, status])
  @@index([toUserId, status])
  @@index([createdAt])
}
